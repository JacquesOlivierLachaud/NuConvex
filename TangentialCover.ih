/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file TangentialCover.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2012/12/09
 *
 * Implementation of inline methods defined in TangentialCover.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
~TangentialCover()
{
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
TangentialCover()
  : myDigSurf( 0 ), myVtx2PtFct( 0 )
{
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
const typename DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::DigitalSurface &
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
surface() const
{
  ASSERT( isValid() );
  return *myDigSurf;
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
typename DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::Point
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
coordinates( const Vertex & v ) const
{
  ASSERT( isValid() );
  return (*myVtx2PtFct)( v );
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
void
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
init( const DigitalSurface & digSurf,
      const Vertex2PointFunctor & v2pFct,
      InternalInteger p, InternalInteger q,
      InternalInteger diameter )
{
  clear();
  myDigSurf = &digSurf;
  myVtx2PtFct = &v2pFct;
  myP = p; myQ = q;
  myDiameter = diameter;
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
void
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
compute( unsigned int nbMaxPerVertex, bool extensionMode )
{
  ASSERT( isValid() );
  clear(); // make sure members are empty
  myNbMaxPerVertex = nbMaxPerVertex;
  Index mp = 0; // Index of the current maximal plane.
  SurfelAreaEstimator areaEstimator( surface() );
  SqED sqed;
  unsigned int size = surface().size();
  unsigned int i = 0;
  for ( typename DigitalSurface::ConstIterator 
          it = surface().begin(), itE = surface().end();
        it != itE; ++it, ++mp, ++i )
    {
      if ( ( i % 100 ) == 0 )
        trace.progressBar( (double) i, (double) size );
      Vertex p = *it;
      SqEDToPoint distanceToPoint( sqed, coordinates( p ) );
      VertexFunctor vfunctor( *myVtx2PtFct, distanceToPoint );
      MyNuConvexSet nuConvex( Visitor( surface(), vfunctor, p ), *myVtx2PtFct );
      nuConvex.setExtensionMode( extensionMode );
      nuConvex.init( myP, myQ, myDiameter );
      nuConvex.compute( -1.0 );
      myMPSTable.push_back( MPS() );
      MPS & mps = myMPSTable.back();
      nuConvex.summarize( mps, areaEstimator );
      // std::cerr << "+- MP at " << p << " = " << mps << std::endl;
      unsigned int nb = 0;
      for ( typename MyNuConvexSet::ConstIterator 
              itNCS = nuConvex.begin(), itNCSEnd = nuConvex.end();
            itNCS != itNCSEnd; ++itNCS, ++nb )
        {
          Vertex vtx = *itNCS;
          addMPSToVertex( vtx, mp );
        }
      // std::cerr << "  +- has " << nb << " vertices." << std::endl; 
    }
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
void
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
computeOnce( unsigned int nbMaxPerVertex, bool extensionMode )
{
  ASSERT( isValid() );
  clear(); // make sure members are empty
  myNbMaxPerVertex = nbMaxPerVertex;
  Index mp = 0; // Index of the current maximal plane.
  SurfelAreaEstimator areaEstimator( surface() );
  SqED sqed;

  // Compute inclusions of planes.
  unsigned int size = surface().size();
  myPlane2CoveringPlane.resize( size );
  for ( Index j = 0; j < size; ++j )
    myPlane2CoveringPlane[ j ] = j;

  myMPSTable.resize( size );
  // myMostCenteredVertices.clear(); // necessary to clear lists.
  // myMostCenteredVertices.resize( size );

  // Compute maximal planes.
  unsigned int i = 0;
  std::vector<MyNuConvexSet*> tableNuConvexSets( size );
  for ( typename DigitalSurface::ConstIterator 
          it = surface().begin(), itE = surface().end();
        it != itE; ++it, ++mp, ++i )
    {
      if ( ( i % 100 ) == 0 )
        trace.progressBar( (double) i, (double) size );
      // Computes the maximal plane for this vertex.
      Vertex p = *it;
      SqEDToPoint distanceToPoint( sqed, coordinates( p ) );
      VertexFunctor vfunctor( *myVtx2PtFct, distanceToPoint );
      MyNuConvexSet* & nuConvex = tableNuConvexSets[ mp ];
      nuConvex = new MyNuConvexSet( Visitor( surface(), vfunctor, p ), *myVtx2PtFct );
      nuConvex->setExtensionMode( extensionMode );
      nuConvex->init( myP, myQ, myDiameter );
      nuConvex->compute( -1.0 );
      nuConvex->sort();
      // Also not necessary, memorizes its statistics.
      MPS & mps = myMPSTable[ mp ];
      nuConvex->summarize( mps, areaEstimator );
      // Checks if this plane is included or includes the other planes that already covers this plane.
      bool isIncluded = false;
      typename MapVertex2MPI::iterator itMap = myMapVtx2MPI.find( p );
      if ( itMap != myMapVtx2MPI.end() )
        { // this vertex is already covered by some planes.
          MaximalPlaneIndices & mpi = itMap->second;      
          // assign correct mp to the vertex.
          cleanMaximalPlaneIndices( mpi );
          // they are now all designing different mp.
          for ( typename MaximalPlaneIndices::const_iterator itMPI = mpi.begin(),
                  itMPIEnd = mpi.end(); itMPI != itMPIEnd; ++itMPI )
            {
              Index otherMP = *itMPI; // no need to call father( *itMPI ) after cleaning.
              MyNuConvexSet* & otherNuConvex = tableNuConvexSets[ otherMP ];
              if ( nuConvex->size() <= otherNuConvex->size() )
                { // either included, same or different.
                  if ( std::includes( otherNuConvex->begin(), otherNuConvex->end(),
                                      nuConvex->begin(), nuConvex->end() ) )
                    {
                      // trace.info() << "- new MP " << mp << " is included in old MP " << otherMP << std::endl;
                      isIncluded = true;
                      setFather( mp, otherMP );
                      break;
                    }
                }
              else // case: nuConvex->size() > otherNuConvex->size() )
                { // either container, same or different.
                  if ( std::includes(  nuConvex->begin(), nuConvex->end(),
                                       otherNuConvex->begin(), otherNuConvex->end() ) )
                    {
                      // trace.info() << "- old MP " << otherMP << " is included in new MP" << mp << std::endl;
                      setFather( otherMP, mp );
                      // trace.info() << "  => freeing it, size was " << otherNuConvex->size() << std::endl;
                      // free it.
                      delete otherNuConvex;
                      otherNuConvex = 0;
                    }
                }
            }
          // all possible planes have been checked.
        }
      if ( isIncluded )
        { // delete it if included.
          // trace.info() << "  => freeing it, size was " << nuConvex->size() << std::endl;
          delete nuConvex;
          nuConvex = 0;
        }
      else 
        { // add mp to each vertex.
          // std::cerr << "+- MP at " << p << " = " << mps << std::endl;
          unsigned int nb = 0;
          for ( typename MyNuConvexSet::ConstIterator 
                  itNCS = nuConvex->begin(), itNCSEnd = nuConvex->end();
                itNCS != itNCSEnd; ++itNCS, ++nb )
            {
              Vertex vtx = *itNCS;
              myMapVtx2MPI[ vtx ].insert( mp ); // vtx belongs to MP mp.
            }
          // std::cerr << "  +- has " << nb << " vertices." << std::endl; 
        }
    } // go to next vertex.

  // Fill minimal informations.
  for ( typename MapVertex2MPI::iterator itMap = myMapVtx2MPI.begin(),
          itMapEnd = myMapVtx2MPI.end(); itMap != itMapEnd; )
    {
      Vertex vtx = itMap->first;
      MaximalPlaneIndices & mpi = itMap->second;
      cleanMaximalPlaneIndices( mpi );
      for ( typename MaximalPlaneIndices::const_iterator itMPI = mpi.begin(),
              itMPIEnd = mpi.end(); itMPI != itMPIEnd; ++itMPI )
        {
          addMPSToVertex( vtx, *itMPI );
        }
      // clear memory.
      typename MapVertex2MPI::iterator itMapTmp = itMap;
      ++itMap;
      myMapVtx2MPI.erase( itMapTmp );
    }
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
void
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
getEstimatedNormal( RealVector & n, Vertex p,
                    AveragingMode nd ) const
{
  std::vector<Scalar> coefs;
  this->getAveragingCoefficients( coefs, p, nd );
  this->getEstimatedNormal( n, p, coefs );
}

//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
void
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
getEstimatedNormal( RealVector & n, Vertex p, 
		    const std::vector<Scalar> & coefs ) const
{
  typename MapVertex2MPSI::const_iterator itMap = myMapVtx2MPSI.find( p );
  ASSERT( itMap != myMapVtx2MPSI.end() );
  const MaximalPlaneSummaryIndices & mpsi = itMap->second;
  ASSERT( coefs.size() >= mpsi.size() );
  n.reset();
  unsigned int i = 0;
  for ( typename MaximalPlaneSummaryIndices::const_iterator 
	  it = mpsi.begin(), it_end = mpsi.end();
	it != it_end; ++it, ++i )
    {
      n += myMPSTable[ *it ].normal * coefs[ i ];
    }
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
void
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
getAveragingCoefficients( std::vector<Scalar> & coefs, 
                          Vertex p, 
			  AveragingMode nd ) const
{
  typename MapVertex2MPSI::const_iterator itMap = myMapVtx2MPSI.find( p );
  ASSERT( itMap != myMapVtx2MPSI.end() );
  const MaximalPlaneSummaryIndices & mpsi = itMap->second;
  unsigned int nb = mpsi.size();
  coefs.resize( nb );
  Scalar sum = 0.0;
  RealPoint px = coordinates( p );
  unsigned int i = 0;
  unsigned int maxi = 0;
  Scalar max = -1.0;
  for ( typename MaximalPlaneSummaryIndices::const_iterator 
	  it = mpsi.begin(), it_end = mpsi.end();
	it != it_end; ++it )
    {
      const MPS & mps = myMPSTable[ *it ];
      Scalar coef = 1.0;
      if ( nd != SimpleAveraging )
	{
	  Scalar d = ( px - mps.center ).norm();
	  if ( nd == RadiusAndDistanceAveraging )
	    coef = mps.radius / ( d + 1.0 );
	  else if ( nd == DistanceAveraging )
	    coef = 1.0 / ( d + 1.0 );
	  else if ( nd == InOutAveraging )
	    coef = d <= mps.radius ? 1.0 : (mps.radius * mps.radius / (d*d) );
	}
      // Max disk or plane
      if ( nd == MaxProjectedPlane )
	{
	  if ( abs( mps.projectedArea ) > max )
	    {
	      max = abs( mps.projectedArea );
	      maxi = i;
	    }
	}
      // End loop.
      coefs[ i++ ] = coef;
      sum += coef;
    }
  if ( nd != MaxProjectedPlane )
    {
      for ( i = 0; i < nb; ++i )
	coefs[ i ] /= sum;
    }
  else
    {
      for ( i = 0; i < nb; ++i )
	coefs[ i ] = ( i == maxi ) ? 1.0 : 0.0;
    }
}

//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
void
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
displayPlanes( std::ostream & out ) const
{
  for ( typename DigitalSurface::ConstIterator 
          it = surface().begin(), itE = surface().end();
        it != itE; ++it )
    {
      Vertex vtx = *it;
      typename MapVertex2MPSI::const_iterator itMap = myMapVtx2MPSI.find( vtx );
      ASSERT( itMap != myMapVtx2MPSI.end() );
      const MaximalPlaneSummaryIndices & mpsi = itMap->second;
      out << "+- vtx=" << vtx << " (";
      for ( unsigned int i = 0; i < mpsi.size(); ++i )
        out << " " << myMPSTable[ mpsi[ i ] ].projectedArea;
      out << " )" << std::endl;
    }
}

//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
typename DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::MaximalPlaneIndicesConstIterator
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
begin( const Vertex & vtx )
{
  return myMapVtx2MPI[ vtx ].begin();
}

//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
typename DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::MaximalPlaneIndicesConstIterator
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
end( const Vertex & vtx )
{
  return myMapVtx2MPI[ vtx ].end();
}

//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
bool
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
addMPSToVertex( Vertex vtx, Index mp )
{
  typename MapVertex2MPSI::iterator itMap = myMapVtx2MPSI.find( vtx );
  if ( itMap == myMapVtx2MPSI.end() )
    {
      myMapVtx2MPSI[ vtx ].push_back( mp );
      return true;
    }
  MaximalPlaneSummaryIndices & mpsi = itMap->second;
  ASSERT( ! mpsi.empty() );
  if ( myAreaComparator( myMPSTable[ mp ], myMPSTable[ mpsi[ 0 ] ] ) )
    { // new plane is smaller than smallest one.
      if ( mpsi.size() != myNbMaxPerVertex )
        { // Put smallest one at the end and add it at the beginning.
          mpsi.push_back( mpsi[ 0 ] );
          mpsi[ 0 ] = mp;
          return true;
        }
      else
        {
          // otherwise the plane is dropped.
          return false;
        }
    }
  else
    { // It is not the smallest one
      if ( mpsi.size() != myNbMaxPerVertex )
        { // Put it at the end.
          mpsi.push_back( mp );
        }
      else
        { // Find the next smallest one.
          mpsi[ 0 ] = mp;
          unsigned int m = 0;
          for ( unsigned int i = 1; i < mpsi.size(); ++i )
            if ( myAreaComparator( myMPSTable[ mpsi[ i ] ], 
                                   myMPSTable[ mpsi[ m ] ] ) )
              {
                m = i;
              }

          if ( m != 0 )
            {
              mpsi[ 0 ] = mpsi[ m ];
              mpsi[ m ] = mp;
            }
        }
      return true;
   }
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
void
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
clear()
{
  myMapVtx2MPSI.clear();
  myMPSTable.clear();
  myMapVtx2MPI.clear();
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
typename DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::Index
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
father( Index mp )
{
  Index f = myPlane2CoveringPlane[ mp ];
  if ( f != mp )
    {
      f = myPlane2CoveringPlane[ mp ] = father( f );
      // // move also vertices.
      // myMostCenteredVertices[ f ].splice( myMostCenteredVertices[ f ].end(), 
      //                                     myMostCenteredVertices[ mp ] );
      return f;
    }
  else
    return f;
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
void
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
setFather( Index mp, Index f )
{
  myPlane2CoveringPlane[ mp ] = f;
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
void
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
cleanMaximalPlaneIndices( MaximalPlaneIndices & mpi )
{
  std::vector< Index > trueMP;
  for ( typename MaximalPlaneIndices::iterator itMPI = mpi.begin(),
          itMPIEnd = mpi.end(); itMPI != itMPIEnd;  )
    {
      Index tentativeMP = *itMPI;
      Index otherMP = father( tentativeMP );
      if ( tentativeMP == otherMP ) 
        ++itMPI;
      else
        {
          typename MaximalPlaneIndices::iterator itMPITmp = itMPI;
          ++itMPI;
          mpi.erase( itMPITmp );
          trueMP.push_back( otherMP );
        }
    }
  // put back true MP indices in map.
  for ( typename std::vector< Index >::const_iterator 
          it = trueMP.begin(), itE = trueMP.end();
        it != itE; ++it )
    mpi.insert( *it );
}
///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
void
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::
selfDisplay ( std::ostream & out ) const
{
  out << "[TangentialCover]";
}

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
bool
DGtal::TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger>::isValid() const
{
  return ( myDigSurf != 0 ) && ( myVtx2PtFct != 0 );
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TDigitalSurface, typename TVertex2PointFunctor,
          typename TInternalInteger >
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		  const TangentialCover<TDigitalSurface, TVertex2PointFunctor, TInternalInteger> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


